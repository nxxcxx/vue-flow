{
  "nodes": [
    {
      "name": "Cloner",
      "uuid": "0a2752fb-5f99-4e5c-b16f-3975e01a4ebf",
      "position": {
        "x": 446,
        "y": 85
      },
      "_fnstr": "this.init = input => {\n  let c = input.Count\n  this.meshes = new THREE.Object3D()\n  Array( c ).fill( null ).map( x => {\n    let mesh = input.Mesh.clone()\n    mesh.material = mesh.material.clone()\n    return this.meshes.add( mesh )\n  } )\n}\n\nthis.process = input => {\n  return {\n    'Mesh[]': this.meshes\n  }\n}\n\nthis.flush = () => {\n  if ( !this.meshes ) return\n  this.meshes.children.forEach( m => {\n    m.geometry.dispose()\n    m.material.dispose()\n  } )\n  delete this.meshes\n}",
      "input": [
        {
          "name": "Count",
          "uuid": "b0d2d8d2-07da-40d8-b7af-700bfcfbe928"
        },
        {
          "name": "Mesh",
          "uuid": "5931e3cb-aebc-44a0-8d9e-8123cfe39f6b"
        }
      ],
      "output": [
        {
          "name": "Mesh[]",
          "uuid": "b2edd98a-99c1-44c9-8776-4a9632de398b"
        }
      ],
      "nodes": [],
      "connections": []
    },
    {
      "name": "DATA",
      "uuid": "68f0eb9c-0d73-4098-8e61-37bdfbb0ad18",
      "position": {
        "x": 201,
        "y": 0
      },
      "_fnstr": "this.init = () => {\n\tthis.clock = new THREE.Clock()\n}\n\nthis.process = () => {\n  let dt = this.clock.getDelta()\n  return {\n    Delta: dt,\n    Time: this.clock.elapsedTime,\n    Count: 1,\n    Gain: 100.0,\n  }\n}\n\nthis.flush = () => {\n}",
      "input": [],
      "output": [
        {
          "name": "Gain",
          "uuid": "e5e379b8-d8c8-447c-9f14-747d35e81697"
        },
        {
          "name": "Time",
          "uuid": "b8855666-0218-47e6-be76-a022ba3bc1d2"
        },
        {
          "name": "Delta",
          "uuid": "dd3e35b0-337b-4218-a17b-d22d001151bc"
        },
        {
          "name": "Count",
          "uuid": "409e1180-5ed1-4a20-98d7-4e2e082e6ead"
        }
      ],
      "nodes": [],
      "connections": []
    },
    {
      "name": "Modifier",
      "uuid": "5a42b102-b884-4cf4-855b-383b50a724b4",
      "position": {
        "x": 586,
        "y": 0
      },
      "_fnstr": "this.init = input => {\n}\n\nthis.process = input => {\n  this.meshes = input.OBJ.children\n  input.OBJ.children.forEach( ( mesh, idx ) => {\n    let si = ( idx + 1 ) / input.Count\n  \tlet sx = Math.pow( input.Freq * ( 1.0 - si ), 2.25 ) * 10.0 + si * 1.0\n    let iv = ( 1.0 - idx / input.Count ) * 0.5\n    mesh.scale.setScalar( sx )\n    mesh.rotation.x += input.Delta * iv\n    mesh.rotation.z += input.Delta * iv\n    mesh.rotation.y += input.Delta * iv\n    mesh.material.uniforms.time.value = input.Time\n    mesh.material.uniforms.freq.value = input.Freq * ( 1.5 - si ) * sx\n    mesh.material.uniforms.color.value.setHSL( Math.cos( ( input.Time * 0.05 ) + idx * ( 0.33 / input.Count ) ), 1.0, 0.5 )\n    // mesh.material.uniforms.opacity.value = 0.1 + ( ( 1.0 - idx / input.Count ) * input.Freq * 0.5 )\n    mesh.material.uniforms.opacity.value = 1.0 + ( ( 1.0 - idx / input.Count ) * input.Freq * 0.5 )\n  } )\n  return {\n    OBJ: input.OBJ\n  }\n}\n\nthis.flush = () => {\n}",
      "input": [
        {
          "name": "Freq",
          "uuid": "61925410-6259-439c-b7cf-711302d07bb5"
        },
        {
          "name": "Time",
          "uuid": "390cb6c1-bfd9-4e24-a0ed-006eb8e91b50"
        },
        {
          "name": "Delta",
          "uuid": "2291b24e-092b-4b17-a039-bafc20c35ff9"
        },
        {
          "name": "Count",
          "uuid": "f0d007d6-6c2f-4c02-beb4-da3434d83696"
        },
        {
          "name": "OBJ",
          "uuid": "a83236f8-1672-4fe2-a275-bdc20172a973"
        }
      ],
      "output": [
        {
          "name": "OBJ",
          "uuid": "7a9e0de0-9b74-42ec-9e5c-db6a411958b1"
        }
      ],
      "nodes": [],
      "connections": []
    },
    {
      "name": "XPack-6B1E",
      "uuid": "6b1e2fe0-0183-4507-a47c-0115739b5beb",
      "position": {
        "x": 311,
        "y": 0
      },
      "_fnstr": "",
      "input": [
        {
          "name": "Gain",
          "uuid": "ef08f013-45e4-484b-a593-445ad6766b88",
          "_via": "5dabaed8-e537-4bf8-8143-47cc65d298f3"
        }
      ],
      "output": [
        {
          "name": "Freq",
          "uuid": "06353fc3-8074-45a0-91c0-359c228f1ef3",
          "_via": "b9b76f45-c707-40cc-96d2-ebe48898427a"
        }
      ],
      "nodes": [
        {
          "name": "VIA",
          "uuid": "01dca6a1-0a2c-46f8-8fbf-5df82cd56ddf",
          "position": {
            "x": 595,
            "y": 80
          },
          "_fnstr": "",
          "input": [
            {
              "name": "Freq",
              "uuid": "b9b76f45-c707-40cc-96d2-ebe48898427a",
              "_via": "06353fc3-8074-45a0-91c0-359c228f1ef3"
            }
          ],
          "output": [],
          "nodes": [],
          "connections": []
        },
        {
          "name": "VIA",
          "uuid": "472250c2-4afc-4972-9fa0-bc3763ce271f",
          "position": {
            "x": 275,
            "y": 50
          },
          "_fnstr": "",
          "input": [],
          "output": [
            {
              "name": "Gain",
              "uuid": "5dabaed8-e537-4bf8-8143-47cc65d298f3",
              "_via": "ef08f013-45e4-484b-a593-445ad6766b88"
            }
          ],
          "nodes": [],
          "connections": []
        },
        {
          "name": "SOUNDCLOUD URL",
          "uuid": "cdc1a18e-8af8-4745-8322-0d3688f2788f",
          "position": {
            "x": 50,
            "y": 60
          },
          "_fnstr": "this.init = () => {\n  setTimeout( () => {\n    this.URL = 'https://soundcloud.com/chris11455/sets/glitch-a-synthwave-mix'\n  }, 1000 )\n}\n\nthis.process = () => {\n  return {\n  \tURL: this.URL\n  }\n}\n\nthis.flush = () => {\n  delete this.URL\n}\n",
          "input": [],
          "output": [
            {
              "name": "URL",
              "uuid": "e683595d-a6ba-4e68-bd0a-9cf2a126ab8f"
            }
          ],
          "nodes": [],
          "connections": []
        },
        {
          "name": "AUDIO",
          "uuid": "b83f8c23-91b3-443e-903d-2420409ae6fb",
          "position": {
            "x": 105,
            "y": 110
          },
          "_fnstr": "this.init = () => {\n  this.audioCtx = new (window.AudioContext || window.webkitAudioContext)()\n}\n\nthis.process = () => {\n  return {\n  \tCtx: this.audioCtx\n  }\n}\n\nthis.flush = () => {\n}\n",
          "input": [],
          "output": [
            {
              "name": "Ctx",
              "uuid": "3f4032ff-a0cf-4cc5-9134-769eb94ce169"
            }
          ],
          "nodes": [],
          "connections": []
        },
        {
          "name": "INP STREAM SRC",
          "uuid": "300a7782-413e-40c3-92e3-d6813d0f6a93",
          "position": {
            "x": 205,
            "y": 95
          },
          "_fnstr": "this.init = ( input ) => {\n\tlet self = this\n\tthis.audio = document.createElement( 'audio' )\n\tthis.audio.crossOrigin = 'anonymous'\n\tthis.audio.play()\n  this.audio.volume = 0.25\n  this.audio.currentTime = Math.random() * 60 * 10\n\tthis.sourceNode = input.Ctx.createMediaElementSource( this.audio )\n\tthis.sourceNode.connect( input.Ctx.destination )\n  \n\tfunction get( url, callback ) {\n\t\tvar request = new XMLHttpRequest()\n\t\trequest.onreadystatechange = () => { \n\t\t\tif ( request.readyState === 4 && request.status === 200 ) {\n\t\t\t\tcallback( request.responseText )\n\t\t\t}\n\t\t}\n\t\trequest.open( 'GET', url, true )\n\t\trequest.send( null )\n\t}\n\n\tlet clientParam = 'client_id=aae0cd3ce269784234bb78aa6d485394'\n  get( `http://api.soundcloud.com/resolve?url=${input.URL}&${clientParam}`, res => {\n    let track = JSON.parse( res )\n    self.audio.src = `${track.stream_url}?${clientParam}`\n  } )\n\t\n}\n\nthis.process = ( input ) => {\n\treturn {\n\t\tNode: this.sourceNode,\n    Ctx: input.Ctx\n\t}\n}\n\nthis.flush = () => {\n\tif ( this.audio ) {\n\t\tthis.audio.pause()\n\t\tthis.audio.currentTime = 0\n    this.audio.src = ''\n\t}\n}",
          "input": [
            {
              "name": "URL",
              "uuid": "f7a3090c-0766-4a9c-87de-364c38cea91c"
            },
            {
              "name": "Ctx",
              "uuid": "67db3c5c-2de2-40bb-8ec7-49eef639dc8e"
            }
          ],
          "output": [
            {
              "name": "Node",
              "uuid": "bfdbb4b9-f795-4d7f-b00a-b8d9ee291bf0"
            },
            {
              "name": "Ctx",
              "uuid": "d8bb6480-5bee-43af-b45e-999bb61facf0"
            }
          ],
          "nodes": [],
          "connections": []
        },
        {
          "name": "GAIN",
          "uuid": "0b5e0509-9ddc-4915-b37f-80507e4aad01",
          "position": {
            "x": 360,
            "y": 80
          },
          "_fnstr": "this.init = ( input ) => {\n  this.gainNode = input.Ctx.createGain()\n}\n\nthis.process = ( input ) => {\n  input.Node && input.Node.connect( this.gainNode )\n  this.gainNode.gain.value = input.Gain || 1.0\n  return {\n  \tNode: this.gainNode,\n    Ctx: input.Ctx\n  }\n}\n\nthis.flush = () => {\n}\n",
          "input": [
            {
              "name": "Gain",
              "uuid": "450bc860-5435-47a5-9e9f-a14c267f87cb"
            },
            {
              "name": "Node",
              "uuid": "96f7984f-4f16-400c-8346-a6fd60d82ca0"
            },
            {
              "name": "Ctx",
              "uuid": "3db90ff7-ca85-41b8-801b-d47464e4d776"
            }
          ],
          "output": [
            {
              "name": "Node",
              "uuid": "54c2bb9f-ba71-4495-b81e-856b9b345ae5"
            },
            {
              "name": "Ctx",
              "uuid": "bd53de6a-745f-40d7-9d33-0680d947d611"
            }
          ],
          "nodes": [],
          "connections": []
        },
        {
          "name": "ANALYZER",
          "uuid": "c9f116bf-c887-45d6-b605-c81c0a417676",
          "position": {
            "x": 480,
            "y": 80
          },
          "_fnstr": "this.init = ( input ) => {\n  this.analyzer = input.Ctx.createAnalyser()\n  this.analyzer.fftSize = 2048\n\tthis.freqArray = new Uint8Array( this.analyzer.frequencyBinCount )\n  // console.log( 'freqBin', this.analyzer.frequencyBinCount )\n}\n\nthis.process = ( input ) => {\n  input.Node && input.Node.connect( this.analyzer )\n  this.analyzer.getByteFrequencyData( this.freqArray )\n  let thres = computeAverage( this.freqArray, 0, 1024 ) / 256\n\treturn {\n\t\tFreq: thres,\n    Ctx: input.Ctx\n\t}\n}\n\nthis.flush = () => {\n}\n\nfunction computeAverage( freqArray, start, end ) {\n\treturn freqArray.slice( start, end ).reduce( ( a, b ) => a + b ) / ( end - start )\n}",
          "input": [
            {
              "name": "Node",
              "uuid": "b85a93b3-8704-4374-b641-48853a268e3e"
            },
            {
              "name": "Ctx",
              "uuid": "338a8a39-b118-4d37-817e-7e6b9233560d"
            }
          ],
          "output": [
            {
              "name": "Freq",
              "uuid": "b8ebc478-00fa-4ee4-a3d9-bdae27e838b4"
            }
          ],
          "nodes": [],
          "connections": []
        }
      ],
      "connections": [
        [
          "5dabaed8-e537-4bf8-8143-47cc65d298f3",
          "450bc860-5435-47a5-9e9f-a14c267f87cb"
        ],
        [
          "b8ebc478-00fa-4ee4-a3d9-bdae27e838b4",
          "b9b76f45-c707-40cc-96d2-ebe48898427a"
        ],
        [
          "e683595d-a6ba-4e68-bd0a-9cf2a126ab8f",
          "f7a3090c-0766-4a9c-87de-364c38cea91c"
        ],
        [
          "3f4032ff-a0cf-4cc5-9134-769eb94ce169",
          "67db3c5c-2de2-40bb-8ec7-49eef639dc8e"
        ],
        [
          "bfdbb4b9-f795-4d7f-b00a-b8d9ee291bf0",
          "96f7984f-4f16-400c-8346-a6fd60d82ca0"
        ],
        [
          "d8bb6480-5bee-43af-b45e-999bb61facf0",
          "3db90ff7-ca85-41b8-801b-d47464e4d776"
        ],
        [
          "54c2bb9f-ba71-4495-b81e-856b9b345ae5",
          "b85a93b3-8704-4374-b641-48853a268e3e"
        ],
        [
          "bd53de6a-745f-40d7-9d33-0680d947d611",
          "338a8a39-b118-4d37-817e-7e6b9233560d"
        ]
      ]
    },
    {
      "name": "Geometry",
      "uuid": "51c574c7-f47f-43cf-aa27-94871e871560",
      "position": {
        "x": 191,
        "y": 100
      },
      "_fnstr": "this.init = input => {\n  \n\n  this.geometry = new THREE.IcosahedronBufferGeometry(\n      400,\n      2\n  )\n\n}\n\nthis.process = input => {\n  return {\n    Geometry: this.geometry\n  }\n}\n\nthis.flush = () => {\n  if ( this.geometry )\n    this.geometry.dispose()\n  delete this.geometry\n}\n",
      "input": [],
      "output": [
        {
          "name": "Geometry",
          "uuid": "6d69b216-e2ea-4a7d-8cb5-3d62bdbaf241"
        }
      ],
      "nodes": [],
      "connections": []
    },
    {
      "name": "Mesh",
      "uuid": "4d9dc0b4-44ba-4626-9087-b42b3be2d5a1",
      "position": {
        "x": 301,
        "y": 130
      },
      "_fnstr": "this.init = input => {\n  setTimeout( () => {\n    this.mesh = new THREE.Mesh(\n      input.Geometry,\n      input.Material\n    )\n  }, 500 )\n}\n\nthis.process = input => {\n  return {\n    Mesh: this.mesh\n  }\n}\n\nthis.flush = () => {\n  if ( !this.mesh ) return\n    this.mesh.geometry.dispose()\n    this.mesh.material.dispose()\n  delete this.mesh\n}\n",
      "input": [
        {
          "name": "Geometry",
          "uuid": "53fdc96c-5491-4483-8b19-7b42f2fe71c8"
        },
        {
          "name": "Material",
          "uuid": "1d14ce97-8ba8-4e0d-9a57-9c592b859331"
        }
      ],
      "output": [
        {
          "name": "Mesh",
          "uuid": "89717ab8-b273-46d2-a24b-9a8c6a63a3d8"
        }
      ],
      "nodes": [],
      "connections": []
    },
    {
      "name": "VERTEX SHDR",
      "uuid": "3542237a-77fb-4736-9e72-a7748ed5ff84",
      "position": {
        "x": 6,
        "y": 185
      },
      "_fnstr": "this.init = () => { this.shader = `\n\nvarying vec2 vUv;\nuniform float time;\nuniform float freq;\n\n#define PI 3.14159265\n\nfloat orenNayarDiffuse(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float roughness,\n  float albedo) {\n  \n  float LdotV = dot(lightDirection, viewDirection);\n  float NdotL = dot(lightDirection, surfaceNormal);\n  float NdotV = dot(surfaceNormal, viewDirection);\n\n  float s = LdotV - NdotL * NdotV;\n  float t = mix(1.0, max(NdotL, NdotV), step(0.0, s));\n\n  float sigma2 = roughness * roughness;\n  float A = 1.0 + sigma2 * (albedo / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));\n  float B = 0.45 * sigma2 / (sigma2 + 0.09);\n\n  return albedo * max(0.0, NdotL) * (A + B * s / t) / PI;\n}\n\nfloat gaussianSpecular(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float shininess) {\n  vec3 H = normalize(lightDirection + viewDirection);\n  float theta = acos(dot(H, surfaceNormal));\n  float w = theta / shininess;\n  return exp(-w*w);\n}\n\nfloat fogFactorExp2(\n  const float dist,\n  const float density\n) {\n  const float LOG2 = -1.442695;\n  float d = density * dist;\n  return 1.0 - clamp(exp2(d * d * LOG2), 0.0, 1.0);\n}\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nfloat mod289(float x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat permute(float x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat taylorInvSqrt(float r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 grad4(float j, vec4 ip)\n  {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n\n  return p;\n  }\n\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\n\nfloat snoise(vec4 v)\n  {\n  const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                        0.276393202250021,  // 2 * G4\n                        0.414589803375032,  // 3 * G4\n                       -0.447213595499958); // -1 + 4 * G4\n\n// First corner\n  vec4 i  = floor(v + dot(v, vec4(F4)) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n//  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n  //  x1 = x0 - i1  + 1.0 * C.xxxx\n  //  x2 = x0 - i2  + 2.0 * C.xxxx\n  //  x3 = x0 - i3  + 3.0 * C.xxxx\n  //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n  vec4 x1 = x0 - i1 + C.xxxx;\n  vec4 x2 = x0 - i2 + C.yyyy;\n  vec4 x3 = x0 - i3 + C.zzzz;\n  vec4 x4 = x0 + C.wwww;\n\n// Permutations\n  i = mod289(i);\n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n}\n\n\n\nvoid main()\t{\n  vUv = uv;\n  float n = snoise( vec4( position * 0.005, time * 1.0 ) );\n\tvec3 normal = normalize( position ) * n * freq * 1000.0;\n  vec4 mvPosition = modelViewMatrix * vec4( position + normal, 1.0 );\n  gl_Position = projectionMatrix * mvPosition;\n}\n\n`}\n\nthis.process = () => { return { VS: this.shader } }",
      "input": [],
      "output": [
        {
          "name": "VS",
          "uuid": "8bd2e18a-01e8-4482-9e01-f8894b221b9d"
        }
      ],
      "nodes": [],
      "connections": []
    },
    {
      "name": "FRAGMENT SHDR",
      "uuid": "a0a72fa1-75dc-49c7-855f-19c5115a5c5c",
      "position": {
        "x": 0,
        "y": 140
      },
      "_fnstr": "this.init = () => {\n  this.shader = `\n\n\t\tvarying vec2 vUv;\n\t\tuniform float time;\n\t\tuniform float opacity;\n\t\tuniform vec3 color;\n\n    void main()\t{\n    \tgl_FragColor = vec4( color, opacity );\n    }\n\n  `\n  \n}\n\nthis.process = () => {\n  return { FS: this.shader }\n}",
      "input": [],
      "output": [
        {
          "name": "FS",
          "uuid": "4fba1c56-58c3-42fb-8831-febbca4c25fb"
        }
      ],
      "nodes": [],
      "connections": []
    },
    {
      "name": "SHADER MATERIAL",
      "uuid": "e44ad26d-fc41-4393-9af8-bbfe1407d593",
      "position": {
        "x": 141,
        "y": 145
      },
      "_fnstr": "this.init = input => {\n  this.uniforms = { \n    time: { value: 1.0 },\n  \tfreq: { value: 1.0 },\n    color: { value: new THREE.Color() },\n    opacity: { value: 1.0 },\n  }\n  this.material = new THREE.ShaderMaterial( { \n\t\tuniforms: this.uniforms,\n    vertexShader: input.VS,\n    fragmentShader: input.FS,\n    wireframe: true,\n    wireframeLinewidth: 1,\n    transparent: true,\n    blending: THREE.AdditiveBlending,\n  } )\n}\n\nthis.process = input => {\n  return {\n    Material: this.material\n  }\n}\n\nthis.flush = () => {\n  if ( this.material )\n    this.material.dispose()\n  delete this.material\n}\n",
      "input": [
        {
          "name": "FS",
          "uuid": "5451002a-b9ba-4cb1-8fc6-17a11bee4d7c"
        },
        {
          "name": "VS",
          "uuid": "3337c08f-0efe-4f26-9ed8-e642852e632a"
        }
      ],
      "output": [
        {
          "name": "Material",
          "uuid": "0174bb58-cf8d-4484-8656-b61d286189ff"
        }
      ],
      "nodes": [],
      "connections": []
    },
    {
      "name": "CAMERA",
      "uuid": "80914c3a-70c6-4d3c-880e-f1b07e664ca6",
      "position": {
        "x": 793,
        "y": 60
      },
      "_fnstr": "this.init = ( input, engine ) => {\n  this.camera = new THREE.PerspectiveCamera( 75, engine.width / engine.height, 1, 10000 )\n  this.camera.position.z = 1000\n  // this.camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 )\n}\n\nthis.process = ( input, engine ) => {\n  this.camera.aspect = engine.width / engine.height\n  this.camera.updateProjectionMatrix()\n  return {\n    Camera: this.camera\n  }\n}\n\nthis.flush = () => {\n  delete this.camera\n}",
      "input": [],
      "output": [
        {
          "name": "Camera",
          "uuid": "13f3fab8-2072-4de7-9e5a-5e647ea39248"
        }
      ],
      "nodes": [],
      "connections": []
    },
    {
      "name": "SCENE",
      "uuid": "ff60190e-b3cf-47d0-9188-e95771ca1c9c",
      "position": {
        "x": 768,
        "y": 100
      },
      "_fnstr": "this.init = input => {\n  this.scene = new THREE.Scene()\n}\n\nthis.process = input => {\n  this.scene.children[ 0 ] = input.OBJ0\n  return {\n    Scene: this.scene\n  }\n}\n\nthis.flush = () => {\n  delete this.scene\n}",
      "input": [
        {
          "name": "OBJ0",
          "uuid": "e4c87c73-7eea-494a-b1cb-c178b48975a0"
        }
      ],
      "output": [
        {
          "name": "Scene",
          "uuid": "e8534b90-307e-46db-9a8f-5454620b961b"
        }
      ],
      "nodes": [],
      "connections": []
    },
    {
      "name": "RENDERER",
      "uuid": "cab842b8-f42a-4376-9f97-96d931fa2f17",
      "position": {
        "x": 955,
        "y": 60
      },
      "_fnstr": "this.init = ( input, engine ) => {\n  let renderer = engine.renderer\n  this.renderer = renderer\n  renderer.setClearColor( 0x000000, 0 )\n  renderer.clear()\n}\n\nthis.process = ( input, engine ) => {\n  let renderer = engine.renderer\n  renderer.render( input.Scene, input.Camera, input.Tex )\n}\n\nthis.flush = ( engine ) => {\n  if ( this.renderer )\n    this.renderer.renderLists.dispose()\n}",
      "input": [
        {
          "name": "Camera",
          "uuid": "ab381cad-7036-4abe-bf6f-edd7b9051d49"
        },
        {
          "name": "Scene",
          "uuid": "2ee00718-03e4-43ab-abc3-3ee5510737b3"
        },
        {
          "name": "Tex",
          "uuid": "dc896038-b144-48e5-b0c9-dc9f81b5d824"
        }
      ],
      "output": [],
      "nodes": [],
      "connections": []
    },
    {
      "name": "RENDER TARGET",
      "uuid": "e1a7b0fc-1061-4af2-ad22-35f7223d5cd8",
      "position": {
        "x": 746,
        "y": 172
      },
      "_fnstr": "this.init = ( input, engine ) => {\n  this.renderer = engine.renderer\n  let size = this.renderer.getSize()\n  this.renderTarget = new THREE.WebGLRenderTarget( size.width, size.height )\n}\n\nthis.process = ( input, engine ) => {\n  return {\n    RT: this.renderTarget\n  }\n}\n\nthis.flush = ( engine ) => {\n}",
      "input": [],
      "output": [
        {
          "name": "RT",
          "uuid": "f28dda29-bfc6-496a-a34e-4e92f40de4eb"
        }
      ],
      "nodes": [],
      "connections": []
    },
    {
      "name": "SHADER MATERIAL",
      "uuid": "8db07fef-783f-42f3-88d9-83dc4525bed8",
      "position": {
        "x": 1048,
        "y": 151
      },
      "_fnstr": "this.init = ( input, engine ) => {\n  let size = engine.renderer.getSize()\n  this.uniforms = { \n    tex: { value: input.RT.texture },\n    resolution: { value: new THREE.Vector2( engine.width, engine.height ) },\n  }\n  this.material = new THREE.ShaderMaterial( { \n\t\tuniforms: this.uniforms,\n    vertexShader: input.VS,\n    fragmentShader: input.FS,\n  } )\n}\n\nthis.process = input => {\n  return {\n    Material: this.material\n  }\n}\n\nthis.flush = () => {\n  if ( this.material )\n    this.material.dispose()\n  delete this.material\n}\n",
      "input": [
        {
          "name": "RT",
          "uuid": "9061ea21-1eb4-46a3-8ac6-6aea85a7b018"
        },
        {
          "name": "VS",
          "uuid": "c8ced03c-5ba6-4ab3-a6cd-1ad5ab6dcf24"
        },
        {
          "name": "FS",
          "uuid": "e6be7240-a30b-42fb-90fe-5702300f33a3"
        }
      ],
      "output": [
        {
          "name": "Material",
          "uuid": "9b39d084-4094-4bec-991d-5734c2f2bead"
        }
      ],
      "nodes": [],
      "connections": []
    },
    {
      "name": "FRAG",
      "uuid": "a410d0e6-078f-4879-843e-2a351bae6d44",
      "position": {
        "x": 883,
        "y": 255
      },
      "_fnstr": "this.init = () => {\n  this.shader = `\n\n/*--------------------------------------------------------------\n * Shader Tiles: Tesselation of the coordinate space into \n * regular polygons. \n *\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n *\n * https://www.shadertoy.com/user/TheVaporTrail\n * Contact: david (at) TheVaporTrail (dot) com\n * Projects: http://www.TheVaporTrail.com\n *\n * Supported tesselations: Square, Triangle, Hexagon, Octagon\n *\n * These routines work with the idea of a \"tile\", which describes\n * a regular polygon. A tile size is given as the radius of a \n * circle that encloses the polygon. The tile definition has the\n * radius, center, and number of sides. It also has a rotation,\n * direction, inner radius, \"horizontal angle\". (The horizontal\n * angle is the angle between the first vertex and horizontal.)\n *\n * Different tesselation \"styles\" are supported. A style describes\n * the orientations and directions of tiles:\n *   STYLE_MATCHING: All tiles have the same direction and same \n *     starting angle (except alternating triangles are rotated 180)\n *   STYLE_SEAMLESS: Triangles and squares are arranged so that all\n *     vertices 0 are together, vertices 1 are together, etc. The \n *     direction will therefore alternate in adjacent tiles.\n *\n * There are two sets of routines: locate routines and calc routines.\n * Locate routines find a tile given a coordinate and a tile size.\n * Calc routines calculate some piece of information given a tile\n * and a coordinate or other argument.\n *\n * Calc routines:\n *   Vertex \n *   Angle (of point in tile relative to horizontal)\n *   Edge vector\n *   Relative Position\n *   Relative Position UV (0.0<=x<=1.0, 0.0<=y<=1.0)\n *   Contains Point\n *   Distance to Edge\n *   Distance to Closest Edge\n *   Distance to Vertex\n *   Distance to Closest Vertex\n *\n *\n *\n *--------------------------------------------------------------*/\n\n#define DegreeToRad (3.14159/180.0)\n#define Tau (3.14159 * 2.0)\n#define cos30 (0.8660254) /* sqrt(3)/2 */\n\n#define TILE_TRI 0\n#define TILE_SQU 1\n#define TILE_HEX 2\n#define TILE_OCT 3\n\n#define STYLE_MATCHING 0\n#define STYLE_SEAMLESS 1\n\n#define TILE_MAX_SIDES 8\n\n/*--------------------------------------------------------------\n *\n *--------------------------------------------------------------*/\nstruct Tile_t\n{\n\tvec2  center;     // Center of the tile\n\tint   sides;      // Number of sides\n\tfloat len;        // Length of the side\n\tfloat radius;     // Radius to the vertex\n\tfloat inner;      // Radius to closest point on the edge\n\tfloat angle;      // Angle to first vertex\n\tfloat horzangle;  // Angle between canonical first vertex and horizontal \n\tint   direction;  // Rotation direction (+1 or -1)\n};\n\n/*--------------------------------------------------------------\n * Locate (Equilateral) Triangle Tile\n *\n * Canonical tile: vertex zero at 90 degrees, alternating tiles rotated 180 degrees\n *\n * Styles:\n *   MATCHING\n *   SEAMLESS\n *--------------------------------------------------------------*/\nTile_t tile_LocateTriangle(vec2 aCoord, int tileStyle, float radius)\n{\n\tTile_t t;\n\t\n\tfloat sideLen = radius * 2.0 * cos30;\n\t\n\t// Compute the size of a box to contain an equilateral triangle with a side of length=sideLen\n\tvec2 boxSize = vec2(sideLen, sideLen * cos30);\n\n\t// Determine if this is even or odd row. First convert the vertical location to a row number\n\t// Determine if it is an odd or even row\n\t// For odd rows, invert the triangle\n\t// -- This inverts the results when y<0 -- int row = int(aCoord.y/boxSize.y);\n\t// -- This inverts the results when y<0 -- bool evenRow = ((row - 2*(row/2)) == 0);\n\tfloat row = floor(aCoord.y/boxSize.y);\n\tbool evenRow = ((row - 2.0*floor(row/2.0)) < 0.01);\n\t\n\t// Compute the center of the triangle relative to the bottom-left corner of the box\n\t// Note that triangles are inverted for odd rows, so the center is shifted\n\tvec2 ctrAdjA = vec2(boxSize.x * 0.5, boxSize.y * (evenRow?1.0:2.0)/3.0);\n\tvec2 coordA  = aCoord.xy;\n\t// Find the box containing the coord, then compute the triangle center\n\tvec2 boxA    = floor(coordA/boxSize);\n\tvec2 ctrA    = boxA * boxSize + ctrAdjA;\n\t// Triangles are inverted on odd rows\n\tfloat angleA = evenRow ? 90.0 : 270.0;\n\tint   dirA   = 1;\n\t\n    if (tileStyle == STYLE_SEAMLESS)\n    {\n\t\tint idx = int(boxA.x - 3.0 * floor(boxA.x/3.0));\n\t\tdirA = evenRow ? 1 : -1;\n\t\tangleA = 330.0 - float(idx) * 120.0;\n\t\tif (!evenRow)\n\t\t\tangleA = -angleA;\n    }\n    \n    // Same as above, but we shift sideways by half a box\n    // and invert all of the triangles\n\tvec2 shiftB  = vec2(boxSize.x * 0.5, 0.0);\n\tvec2 ctrAdjB = vec2(boxSize.x * 0.5, boxSize.y * (evenRow?2.0:1.0)/3.0);\n\tvec2 coordB  = aCoord.xy + shiftB;\n\tvec2 boxB    = floor((coordB)/boxSize);\n\tvec2 ctrB    = boxB * boxSize - shiftB + ctrAdjB;\n\tfloat angleB = evenRow ? 270.0 : 90.0;\n\tint   dirB   = 1;\n\t\n    if (tileStyle == STYLE_SEAMLESS)\n    {\n\t\tint idx = int(boxB.x - 3.0 * floor((boxB.x)/3.0));\n\t\tdirB = evenRow ? -1 : 1;\n\t\tangleB = 150.0 + float(idx) * 120.0;\n\t\tif (!evenRow)\n\t\t\tangleB = -angleB;\n    }\n\t\n\tbool chooseA = (distance(aCoord, ctrA) < distance(aCoord, ctrB));\n\tvec2 ctr     = (chooseA) ? ctrA : ctrB;\n\tfloat angle  = (chooseA) ? angleA : angleB;\n    int   dir    = (chooseA) ? dirA : dirB;\n\n\tt.center    = ctr;\n\tt.len       = sideLen;\n\tt.sides     = 3;\n\tt.radius    = radius;\n\tt.inner     = sideLen/4.0;\n\tt.angle     = angle;\n\tt.horzangle = -90.0;\n\tt.direction = dir;\n\t\n\t\n\treturn t;\n}\n\n/*--------------------------------------------------------------\n *\n *--------------------------------------------------------------*/\nTile_t tile_LocateHexagon(vec2 aCoord, int tileStyle, float radius)\n{\n\tTile_t t;\n\t\n\tfloat sideLen = radius;\n\t\n\t// Compute the size of a box to contain hexagon with a side of length=sideLen\n\tvec2 boxSize = vec2(sideLen * 3.0, sideLen*cos30*2.0);\n\tfloat hexWidth = sideLen * 2.0;\n\n\t// Convert the vertical location to a row number\n\tfloat row = floor(aCoord.y/boxSize.y);\n\t\n\t// Determine if it is an odd or even row\n\t// For odd rows, invert the triangle\n\tbool evenRow = ((row - 2.0*floor(row/2.0)) < 0.01);\n\t\n\tvec2 ctrAdj = vec2(sideLen, sideLen * cos30);\n\t\n\tvec2 shiftA  = vec2(0.0);\n\tfloat angleA = 0.0;\n\tint   dirA   = evenRow ? 1 : -1;\n\tvec2 coordA  = aCoord.xy + shiftA;\n\tvec2 boxA    = floor(coordA/boxSize);\n\tvec2 ctrA    = boxA * boxSize - shiftA + ctrAdj;\n\tbool hasA    = (coordA.x - boxA.x * boxSize.x < hexWidth);\n\n\tvec2 shiftB  = vec2(sideLen + sideLen * 0.5, sideLen * cos30);\n\tfloat angleB = 0.0;\n\tint   dirB   = evenRow ? 1 : -1;\n\tvec2 coordB  = aCoord.xy + shiftB;\n\tvec2 boxB    = floor((coordB)/boxSize);\n\tvec2 ctrB    = boxB * boxSize - shiftB + ctrAdj;\n\tbool hasB    = (coordB.x - boxB.x * boxSize.x < hexWidth);\n\t\n\tbool chooseA = (!hasB || (hasA && distance(aCoord, ctrA) < distance(aCoord, ctrB)));\n\tvec2 ctr     = (chooseA) ? ctrA : ctrB;\n\tfloat angle  = (chooseA) ? angleA : angleB;\n    int   dir    = (chooseA) ? dirA : dirB;\n\n\tt.center    = ctr;\n\tt.len       = sideLen;\n\tt.sides     = 6;\n\tt.radius    = radius;\n\tt.inner     = sideLen/cos30;\n\tt.angle     = angle;\n\tt.horzangle = -30.0;\n\tt.direction = 1;\n\t\n\treturn t;\n}\n\n/*--------------------------------------------------------------\n *\n *--------------------------------------------------------------*/\nTile_t tile_LocateSquare(vec2 aCoord, int tileStyle, float radius)\n{\n\tTile_t t;\n\t\n\tfloat sideLen = radius*sqrt(2.0);\n\t\n\t// Compute the size of a box \n\tvec2 boxSize = vec2(sideLen, sideLen);\n\n\t// Convert the vertical location to a row number\n\tfloat row = floor(aCoord.y/boxSize.y);\n\t\n\t// Determine if it is an odd or even row\n\tbool evenRow = ((row - 2.0*floor(row/2.0)) < 0.01);\n\t\n\t\n\tfloat angle   = 45.0;\n\tvec2  coord   = aCoord.xy;\n\tvec2  box     = floor(coord/boxSize);\n\tvec2  ctr     = box * boxSize + boxSize/2.0;\n\n\tt.center    = ctr;\n\tt.len       = sideLen;\n\tt.sides     = 4;\n\tt.radius    = radius;\n\tt.inner     = sideLen/2.0;\n\tt.angle     = angle;\n\tt.horzangle = -45.0;\n\tt.direction = 1;\n\t\n\treturn t;\n}\n\n/*--------------------------------------------------------------\n *\n *--------------------------------------------------------------*/\nTile_t tile_LocateOctagon(vec2 aCoord, int tileStyle, float radius)\n{\n\tTile_t t;\n\t\n\tfloat sideLen = radius * 2.0 * sin(Tau/16.0);\n\tfloat inner   = radius * cos(Tau/16.0);\n\t\n\t// Compute the size of a box \n\tvec2 octBoxSize = vec2(inner * 2.0, inner * 2.0);\n\n\tfloat angle   = 360.0/16.0;\n\tvec2  coord   = aCoord.xy;\n\tvec2  box     = floor(coord/octBoxSize);\n\tvec2  ctrOct  = box * octBoxSize + octBoxSize/2.0;\n\n\t// Compute the size of the grid to locate the squares\n\t// The squares are rotated 45 degrees, so the \"width\" is measured across the diagonal..\n\tfloat squRadius   = sideLen / sqrt(2.0);\n\tvec2 squBoxSize   = vec2(squRadius * 2.0 + sideLen);\n\tvec2 shiftB  = vec2(sideLen + squRadius, sideLen + squRadius);\n\tvec2 coordB  = aCoord.xy - shiftB;\n\tvec2 boxB    = floor((coordB)/squBoxSize);\n\tvec2 ctrSqu  = boxB * squBoxSize + shiftB + vec2(squRadius);\n\t// We can use the fact that the sides of the square are diagonal lines with \n\t// slope=+1 or slope=-1 to determine if a point is in the square.\n\tvec2 relPt   = coordB - boxB * squBoxSize - vec2(squRadius);\n\tbool inSqu   = ((abs(relPt.x) + abs(relPt.y)) < squRadius);\n\t//bool hasSqu  = ((coordB.x - boxB.x * squBoxSize.x < squRadius * 2.0) && (coordB.y - boxB.y * squBoxSize.y < squRadius * 2.0));\n\n\tif (inSqu)\n\t{\n\t\tt.center    = ctrSqu;\n\t\tt.len       = sideLen;\n\t\tt.sides     = 4;\n\t\tt.radius    = squRadius;\n\t\tt.inner     = squRadius/sqrt(2.0);\n\t\tt.angle     = 0.0;\n\t\tt.horzangle = 0.0;\n\t\tt.direction = 1;\n\t}\n\telse\n\t{\n\t\tt.center    = ctrOct;\n\t\tt.len       = sideLen;\n\t\tt.sides     = 8;\n\t\tt.radius    = radius;\n\t\tt.inner     = inner;\n\t\tt.angle     = angle;\n\t\tt.horzangle = -360.0/16.0;\n\t\tt.direction = 1;\n\t}\n\t\n\treturn t;\n}\n\n/*--------------------------------------------------------------\n * Locate dispatch routine\n *--------------------------------------------------------------*/\nTile_t tile_Locate(vec2 aCoord, int tileType, int tileStyle, float radius)\n{\n\tTile_t t;\n\t\n\tif (tileType == TILE_TRI)\n\t\tt = tile_LocateTriangle(aCoord, tileStyle, radius);\n\telse if (tileType == TILE_SQU)\n\t\tt = tile_LocateSquare(aCoord, tileStyle, radius);\n\telse if (tileType == TILE_HEX)\n\t\tt = tile_LocateHexagon(aCoord, tileStyle, radius);\n\telse if (tileType == TILE_OCT)\n\t\tt = tile_LocateOctagon(aCoord, tileStyle, radius);\n\t\n\treturn t;\n}\n\n\n/*--------------------------------------------------------------\n *\n *--------------------------------------------------------------*/\nvec2 tile_CalcVertex(Tile_t tile, int vertexIdx)\n{\n\tvec2 pt;\n\tfloat angle;\n\t\n\tangle = DegreeToRad * (tile.angle + float(vertexIdx) * float(tile.direction) * 360.0 / float(tile.sides));\n\t\n\tpt.x = tile.center.x + tile.radius * cos(angle);\n\tpt.y = tile.center.y + tile.radius * sin(angle);\n\t\n\treturn pt;\n}\n\n/*--------------------------------------------------------------\n * Calculate the angle between two vectors, one from the center\n * to the coord and the other between the center and vertex zero\n *--------------------------------------------------------------*/\nfloat tile_CalcAngle(Tile_t tile, vec2 coord)\n{\n\tfloat angle = 0.0;\n\t\n\tangle = atan(coord.y - tile.center.y, coord.x - tile.center.x) / DegreeToRad;\n\t\n\tangle += tile.angle;\n\t\n\tangle *= float(tile.direction);\n\t\n\treturn angle;\n}\n\n/*--------------------------------------------------------------\n *\n *--------------------------------------------------------------*/\nvec2 tile_CalcEdgeVector(Tile_t tile, int vertexIdx)\n{\n\tvec2 vect;\n\t\n\treturn vect;\n}\n\n\n/*--------------------------------------------------------------\n * Calculate the position of a coordinate relative to vertex 0,\n * taking into consideration the direction of the tile.\n * The result is -radius<=x<=radius, -radius<=y<=radius\n *--------------------------------------------------------------*/\nvec2 tile_CalcRelPosition(Tile_t tile, vec2 coord, float twist)\n{\n\tvec2 relPos;\n\t\n\tfloat angle = -(tile.angle + tile.horzangle + twist * float(tile.direction)) *  DegreeToRad;\n\t\n\tfloat cA = cos(angle);\n\tfloat sA = sin(angle);\n\t\n\tmat2 rm = mat2(cA, sA, -sA, cA);\n\t\n\trelPos = coord - tile.center;\n\t\n\trelPos = rm * relPos;\n\t\n\tif (tile.direction == -1)\n\t\trelPos.x = -relPos.x;\n\treturn relPos;\n}\n\n\n/*--------------------------------------------------------------\n * Calculate the relative position, but return values appropriate\n * for a texture lookup.\n *--------------------------------------------------------------*/\nvec2 tile_CalcRelPositionUV(Tile_t tile, vec2 coord, float twist)\n{\n\tvec2 relPos = tile_CalcRelPosition(tile, coord, twist);\n\t\n\tvec2 uv = (relPos + vec2(tile.radius, tile.radius))/(tile.radius * 2.0);\n\t\n\treturn uv;\n}\n\n\n/*--------------------------------------------------------------\n *\n *--------------------------------------------------------------*/\nbool tile_ContainsPoint(Tile_t tile, vec2 coord)\n{\n\tbool contains = true;\n\t\n\treturn contains;\n}\n\n\n/*--------------------------------------------------------------\n * Calculate the distance to a specified edge\n *--------------------------------------------------------------*/\nfloat tile_CalcDistanceToEdge(Tile_t tile, int vertexIdx, vec2 coord)\n{\n\tfloat d;\n\t\n\tvec2 v1 = tile_CalcVertex(tile, vertexIdx);\n\tvec2 v2 = tile_CalcVertex(tile, vertexIdx+1);\n\t//vec2 edgeVec = edgeVector_Tile(tile, vertexIdx);\n\t\n\t// Calc distance to line\n\tvec2 vhat = vec2(v2.y - v1.y, v1.x - v2.x);\n\tvec2 r = v1 - coord;\n\t\n\td = abs(dot(vhat, r))/length(vhat);\n\t\n\treturn d;\n}\n\n/*--------------------------------------------------------------\n * Calculate the distance to the closest edge\n *--------------------------------------------------------------*/\nfloat tile_CalcDistanceToClosestEdge(Tile_t tile, vec2 coord)\n{\n\tfloat closest;\n\tfloat dist;\n\t\n\tclosest = tile_CalcDistanceToEdge(tile, 0, coord);\n\t\n\tfor (int i = 1; i < TILE_MAX_SIDES; i++)\n\t{\n\t\tif (i < tile.sides)\n\t\t{\n\t\t\tdist = tile_CalcDistanceToEdge(tile, i, coord);\n\t\t\tif (dist < closest)\n\t\t\t\tclosest = dist;\n\t\t}\n\t}\n\t\n\treturn closest;\n}\n\n\n/*--------------------------------------------------------------\n *\n *--------------------------------------------------------------*/\nfloat tile_CalcDistanceToVertex(Tile_t tile, int vertexIdx, vec2 coord)\n{\n\tvec2 pt = tile_CalcVertex(tile, vertexIdx);\n\n\treturn distance(coord, pt);\n}\n\n/*--------------------------------------------------------------\n *\n *--------------------------------------------------------------*/\nfloat tile_CalcDistanceToClosestVertex(Tile_t tile, vec2 coord)\n{\n\tfloat closest;\n\tfloat dist;\n\t\n\tclosest = tile_CalcDistanceToVertex(tile, 0, coord);\n\t\n\t\n\tfor (int i = 1; i < TILE_MAX_SIDES; i++)\n\t{\n\t\tif (i < tile.sides)\n\t\t{\n\t\t\tdist = tile_CalcDistanceToVertex(tile, i, coord);\n\t\t\tif (dist < closest)\n\t\t\t\tclosest = dist;\n\t\t\t\t\t\n\t\t}\n\t}\n\t\n\treturn closest;\n}\n\n/*--------------------------------------------------------------\n *\n *--------------------------------------------------------------*/\n\nvarying vec2 vUv;\nuniform sampler2D tex;\nuniform vec2 resolution;\n\nvoid main()\n{\n\t// x position determines size\n\tfloat size = 120.0;\n\t\n\tvec2 fragCoord = vUv * resolution;\n\t// Locate a tile\n\tTile_t tile = tile_Locate(fragCoord, TILE_TRI, STYLE_SEAMLESS, size);\t\n\n\t// Convert coordinate to a relative position in the tile\n\tvec2 uv = tile_CalcRelPositionUV(tile, fragCoord, 0.0);\n\t\n\t// Texture look-up\n\tgl_FragColor = texture2D(tex, uv);\n\t// gl_FragColor = texture2D( tex, vUv );\n\t// gl_FragColor = vec4( vec3( vUv, 1.0 ), 1.0 );\n}\n\n\n  `\n  \n}\n\nthis.process = () => { return { FS: this.shader } }",
      "input": [],
      "output": [
        {
          "name": "FS",
          "uuid": "23437011-ec8b-4838-94ae-43859ffd838d"
        }
      ],
      "nodes": [],
      "connections": []
    },
    {
      "name": "VERT",
      "uuid": "5104e562-b575-4593-963d-2149096a92b9",
      "position": {
        "x": 885,
        "y": 217
      },
      "_fnstr": "this.init = () => { this.shader = `\n\nvarying vec2 vUv;\n\nvoid main()\t{\n  vUv = uv;\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  gl_Position = projectionMatrix * mvPosition;\n}\n\n`}\n\nthis.process = () => { return { VS: this.shader } }",
      "input": [],
      "output": [
        {
          "name": "VS",
          "uuid": "51a84451-453c-4614-98d9-77675c572cf3"
        }
      ],
      "nodes": [],
      "connections": []
    },
    {
      "name": "GEOMETRY",
      "uuid": "4ed79de6-e300-475d-bbea-3d5fc32637f8",
      "position": {
        "x": 1068,
        "y": 98
      },
      "_fnstr": "this.init = input => {\n  this.geometry = new THREE.PlaneBufferGeometry( 2, 2 )\n}\n\nthis.process = input => {\n  return {\n    Geometry: this.geometry\n  }\n}\n\nthis.flush = () => {\n  if ( this.geometry )\n    this.geometry.dispose()\n  delete this.geometry\n}\n",
      "input": [],
      "output": [
        {
          "name": "Geometry",
          "uuid": "4a563cd3-49ee-4a1e-97b0-09b18304ccd5"
        }
      ],
      "nodes": [],
      "connections": []
    },
    {
      "name": "MESH",
      "uuid": "1ac95b65-bec6-4302-85f5-6eef5b5b4bd4",
      "position": {
        "x": 1177,
        "y": 120
      },
      "_fnstr": "this.init = input => {\n    this.mesh = new THREE.Mesh(\n      input.Geometry,\n      input.Material\n    )\n}\n\nthis.process = input => {\n  return {\n    Mesh: this.mesh\n  }\n}\n\nthis.flush = () => {\n  if ( !this.mesh ) return\n    this.mesh.geometry.dispose()\n    this.mesh.material.dispose()\n  delete this.mesh\n}\n",
      "input": [
        {
          "name": "Geometry",
          "uuid": "f4393599-ace9-4934-9a47-4ce527ff7758"
        },
        {
          "name": "Material",
          "uuid": "fe4f66b8-9ed2-4ce2-9db2-5d27f887f208"
        }
      ],
      "output": [
        {
          "name": "Mesh",
          "uuid": "381ffdd7-a654-4f39-b2e9-6a42178967d6"
        }
      ],
      "nodes": [],
      "connections": []
    },
    {
      "name": "SCENE",
      "uuid": "afc2eda7-8014-4f97-88e8-7ad47440e1e1",
      "position": {
        "x": 1334,
        "y": 102
      },
      "_fnstr": "this.init = input => {\n  this.scene = new THREE.Scene()\n}\n\nthis.process = input => {\n  this.scene.children[ 0 ] = input.OBJ0\n  return {\n    Scene: this.scene\n  }\n}\n\nthis.flush = () => {\n  delete this.scene\n}",
      "input": [
        {
          "name": "OBJ0",
          "uuid": "062e1981-d729-4120-99f7-d5bbc4923adb"
        }
      ],
      "output": [
        {
          "name": "Scene",
          "uuid": "ef1258f9-2f23-4abf-900e-7f6e8b7a3724"
        }
      ],
      "nodes": [],
      "connections": []
    },
    {
      "name": "CAMERA",
      "uuid": "7512290d-98d4-4ae5-b857-b35da1d754fa",
      "position": {
        "x": 1368,
        "y": 59
      },
      "_fnstr": "this.init = ( input, engine ) => {\n  this.camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 )\n}\n\nthis.process = ( input, engine ) => {\n  this.camera.aspect = engine.width / engine.height\n  this.camera.updateProjectionMatrix()\n  return {\n    Camera: this.camera\n  }\n}\n\nthis.flush = () => {\n  delete this.camera\n}",
      "input": [],
      "output": [
        {
          "name": "Camera",
          "uuid": "0ae7e74a-edc5-4669-82da-c8ee3900a5bf"
        }
      ],
      "nodes": [],
      "connections": []
    },
    {
      "name": "RENDERER",
      "uuid": "a3104426-74de-4bb3-a5b0-38bc1d386d18",
      "position": {
        "x": 1500,
        "y": 80
      },
      "_fnstr": "this.init = ( input, engine ) => {\n  let renderer = engine.renderer\n  this.renderer = renderer\n  renderer.setClearColor( 0x000000, 0 )\n  renderer.clear()\n}\n\nthis.process = ( input, engine ) => {\n  let renderer = engine.renderer\n  renderer.render( input.Scene, input.Camera )\n}\n\nthis.flush = ( engine ) => {\n  if ( this.renderer )\n    this.renderer.renderLists.dispose()\n}",
      "input": [
        {
          "name": "Camera",
          "uuid": "3297194d-b747-472d-83a7-6e7ba03d9ed7"
        },
        {
          "name": "Scene",
          "uuid": "38aa03ec-6b68-46c9-88c7-3d69bba6edb6"
        }
      ],
      "output": [],
      "nodes": [],
      "connections": []
    }
  ],
  "connections": [
    [
      "dd3e35b0-337b-4218-a17b-d22d001151bc",
      "2291b24e-092b-4b17-a039-bafc20c35ff9"
    ],
    [
      "b8855666-0218-47e6-be76-a022ba3bc1d2",
      "390cb6c1-bfd9-4e24-a0ed-006eb8e91b50"
    ],
    [
      "409e1180-5ed1-4a20-98d7-4e2e082e6ead",
      "b0d2d8d2-07da-40d8-b7af-700bfcfbe928"
    ],
    [
      "409e1180-5ed1-4a20-98d7-4e2e082e6ead",
      "f0d007d6-6c2f-4c02-beb4-da3434d83696"
    ],
    [
      "b2edd98a-99c1-44c9-8776-4a9632de398b",
      "a83236f8-1672-4fe2-a275-bdc20172a973"
    ],
    [
      "e5e379b8-d8c8-447c-9f14-747d35e81697",
      "ef08f013-45e4-484b-a593-445ad6766b88"
    ],
    [
      "06353fc3-8074-45a0-91c0-359c228f1ef3",
      "61925410-6259-439c-b7cf-711302d07bb5"
    ],
    [
      "6d69b216-e2ea-4a7d-8cb5-3d62bdbaf241",
      "53fdc96c-5491-4483-8b19-7b42f2fe71c8"
    ],
    [
      "89717ab8-b273-46d2-a24b-9a8c6a63a3d8",
      "5931e3cb-aebc-44a0-8d9e-8123cfe39f6b"
    ],
    [
      "8bd2e18a-01e8-4482-9e01-f8894b221b9d",
      "3337c08f-0efe-4f26-9ed8-e642852e632a"
    ],
    [
      "4fba1c56-58c3-42fb-8831-febbca4c25fb",
      "5451002a-b9ba-4cb1-8fc6-17a11bee4d7c"
    ],
    [
      "0174bb58-cf8d-4484-8656-b61d286189ff",
      "1d14ce97-8ba8-4e0d-9a57-9c592b859331"
    ],
    [
      "13f3fab8-2072-4de7-9e5a-5e647ea39248",
      "ab381cad-7036-4abe-bf6f-edd7b9051d49"
    ],
    [
      "e8534b90-307e-46db-9a8f-5454620b961b",
      "2ee00718-03e4-43ab-abc3-3ee5510737b3"
    ],
    [
      "7a9e0de0-9b74-42ec-9e5c-db6a411958b1",
      "e4c87c73-7eea-494a-b1cb-c178b48975a0"
    ],
    [
      "f28dda29-bfc6-496a-a34e-4e92f40de4eb",
      "dc896038-b144-48e5-b0c9-dc9f81b5d824"
    ],
    [
      "f28dda29-bfc6-496a-a34e-4e92f40de4eb",
      "9061ea21-1eb4-46a3-8ac6-6aea85a7b018"
    ],
    [
      "23437011-ec8b-4838-94ae-43859ffd838d",
      "e6be7240-a30b-42fb-90fe-5702300f33a3"
    ],
    [
      "51a84451-453c-4614-98d9-77675c572cf3",
      "c8ced03c-5ba6-4ab3-a6cd-1ad5ab6dcf24"
    ],
    [
      "4a563cd3-49ee-4a1e-97b0-09b18304ccd5",
      "f4393599-ace9-4934-9a47-4ce527ff7758"
    ],
    [
      "9b39d084-4094-4bec-991d-5734c2f2bead",
      "fe4f66b8-9ed2-4ce2-9db2-5d27f887f208"
    ],
    [
      "381ffdd7-a654-4f39-b2e9-6a42178967d6",
      "062e1981-d729-4120-99f7-d5bbc4923adb"
    ],
    [
      "ef1258f9-2f23-4abf-900e-7f6e8b7a3724",
      "38aa03ec-6b68-46c9-88c7-3d69bba6edb6"
    ],
    [
      "0ae7e74a-edc5-4669-82da-c8ee3900a5bf",
      "3297194d-b747-472d-83a7-6e7ba03d9ed7"
    ]
  ]
}
